//
// README
//  - This code reads a little awkwardly because DAL often means
//    "database access layer".  Here however I'm using it to mean the
//    "Data access layer" because it accesses multiple databases.  I'm new to
//    couchdb and, for better or worse, am trying an approach where each
//    database is basically a table in rdbms land.
//

//---------//
// Imports //
//---------//

import createMethodToApproveArgs from './create-method-to-approve-args'
import databaseNameToDefinition from './database-name-to-definition'
import sectionToCreateErrorMessage from './section-to-create-error-message'

import { methods } from './helpers'
import { couchdb } from 'server/api'
import { createCouchdbId } from '../couchdb-id-utils'
import { dashelize } from 'universal/utils'
import { createHandleServerError, handleServerErrorSync } from 'server/utils'
import {
  assignOver,
  combine,
  hasOwnEnumerableKey as hasKey,
  invoke,
  keepWhen,
  map,
  mMap,
  mSet,
  passThrough,
  reduce,
} from 'fes'

//
//------//
// Main //
//------//

const databaseNameToAccessLayer = mMap(definitionToAccessLayer)(
    databaseNameToDefinition
  ),
  defaultOptions = {
    returnRawResponse: false,
    allow404: false,
  },
  applyDefaults = assignOver(defaultOptions)

//
//------------------//
// Helper Functions //
//------------------//

function definitionToAccessLayer(databaseDefinition, databaseName) {
  const { fields } = databaseDefinition

  const couchdbAccessor = couchdb.createDbAccessor(dashelize(databaseName)),
    methodToApproveArgs = createMethodToApproveArgs(databaseDefinition),
    fieldToAutogenerate = passThrough(fields, [
      keepWhen(hasKey('autogenerate')),
      reduce(
        (result, field) => mSet(field.name, field.autogenerate)(result),
        {}
      ),
    ])

  return reduce(toAccessLayer, {})(methods)

  // helper functions scoped to 'definitionToAccessLayer'

  function toAccessLayer(result, method) {
    return mSet(method, accessor)(result)

    // helper functions scoped to 'toAccessLayer'

    function accessor(...args) {
      const errorArgs = [method, databaseName, args],
        reject = (section, error) => {
          const message = sectionToCreateErrorMessage[section](...errorArgs)

          error.message = message.detailed + '\n\n' + error.message
          return handleServerErrorSync(message.friendly, error)
        }

      try {
        const error = methodToApproveArgs[method](...args)
        if (error) return reject('invalidArgs', error)

        // input is valid woo woo

        const handleServerError = createHandleServerError(
          sectionToCreateErrorMessage.couchdb,
          errorArgs
        )
        let validArg = args[0],
          couchdbMethod = `${method}Document`

        const options = applyDefaults(args[1] || {})

        if (method === 'get' && validArg._rev) {
          couchdbMethod += 'AtRevision'
        } else if (method === 'create') {
          const autogeneratedFields = map(invoke)(fieldToAutogenerate)

          validArg = combine(validArg)(autogeneratedFields)

          if (!validArg._id) validArg._id = createCouchdbId()
        }

        return couchdbAccessor[couchdbMethod](validArg, options).catch(
          handleServerError
        )
      } catch (error) {
        return reject('fallback', error)
      }
    }
  }
}

//
//---------//
// Exports //
//---------//

export default databaseNameToAccessLayer
